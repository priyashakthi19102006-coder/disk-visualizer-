<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disk Scheduling Algorithm Visualizer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#4f46e5', // Indigo 600
                        'secondary': '#10b981', // Emerald 500
                        'accent': '#f59e0b', // Amber 500
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Custom styles for canvas and responsiveness */
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .visualizer-card {
            background-color: white;
            padding: 2rem;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
    </style>
</head>
<body class="min-h-screen">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-extrabold text-gray-800">Disk Scheduling Visualizer</h1>
            <p class="text-lg text-gray-500 mt-2">Visualize algorithms like FCFS, SSTF, SCAN, and LOOK disk management.</p>
        </header>

        <!-- Disk Scheduling Visualizer Module -->
        <div id="disk-visualizer" class="visualizer-card">
            <h2 class="text-3xl font-semibold mb-6 text-primary border-b pb-2">Disk Scheduling</h2>

            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
                <!-- Input Form -->
                <div class="lg:col-span-1 p-4 bg-gray-50 rounded-lg shadow-inner">
                    <h3 class="text-xl font-medium mb-4 text-gray-700">Inputs</h3>
                    <div class="space-y-3">
                        <input type="number" id="disk-request" placeholder="Add Request Track (e.g., 55)" min="0" class="w-full p-2 border border-gray-300 rounded-md focus:ring-primary focus:border-primary">
                        <button onclick="addRequest()" class="w-full bg-secondary text-white py-2 rounded-md hover:bg-emerald-600 transition duration-200 shadow-md">Add Request</button>

                        <hr class="border-gray-300">

                        <input type="number" id="disk-head-position" placeholder="Initial Head Position (e.g., 50)" value="50" min="0" class="w-full p-2 border border-gray-300 rounded-md focus:ring-primary focus:border-primary">
                        <input type="number" id="disk-size" placeholder="Disk Size (Max Track, e.g., 199)" value="199" min="0" class="w-full p-2 border border-gray-300 rounded-md focus:ring-primary focus:border-primary">
                    </div>

                    <div class="mt-6">
                        <label for="disk-algorithm" class="block text-sm font-medium text-gray-700 mb-2">Select Algorithm</label>
                        <select id="disk-algorithm" class="w-full p-2 border border-gray-300 rounded-md focus:ring-primary focus:border-primary">
                            <option value="fcfs">First Come, First Served (FCFS)</option>
                            <option value="sstf">Shortest Seek Time First (SSTF)</option>
                            <option value="scan">SCAN (Elevator)</option>
                            <option value="cscan" disabled>C-SCAN (Circular SCAN)</option>
                            <option value="look" disabled>LOOK</option>
                            <option value="clook" disabled>C-LOOK</option>
                        </select>
                        <button onclick="runDiskVisualizer()" class="w-full mt-4 bg-primary text-white py-3 rounded-md hover:bg-indigo-600 transition duration-200 shadow-lg font-semibold">Run Disk Visualizer</button>
                    </div>
                </div>

                <!-- Request Queue & Results -->
                <div class="lg:col-span-2">
                    <h3 class="text-xl font-medium mb-4 text-gray-700">Request Queue</h3>
                    <div class="p-4 bg-white border border-gray-200 rounded-lg shadow-inner mb-6 h-48 overflow-y-auto">
                        <div id="disk-request-list" class="flex flex-wrap gap-2">
                            <!-- Request tags will be inserted here -->
                        </div>
                    </div>

                    <h3 class="text-xl font-medium mb-4 text-gray-700">Results Summary</h3>
                    <div id="disk-results-summary" class="bg-indigo-50 p-4 rounded-lg shadow-inner">
                        <p class="text-lg font-medium text-gray-700">Total Seek Time: <span id="total-seek-time" class="font-bold text-primary">0</span></p>
                        <p class="text-lg font-medium text-gray-700">Average Seek Time: <span id="avg-seek-time" class="font-bold text-primary">0.00</span></p>
                    </div>
                </div>
            </div>

            <!-- Disk Movement Visualization -->
            <div class="mt-8">
                <h3 class="text-2xl font-semibold mb-4 text-gray-700">Disk Head Movement Visualization</h3>
                <div class="border border-gray-300 rounded-lg p-2 bg-white overflow-x-auto">
                    <canvas id="disk-movement-chart" class="w-full h-64"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript Logic -->
    <script>
        // --- Global State ---
        const AppState = {
            diskRequests: [],
            colors: ['#4f46e5', '#10b981', '#f59e0b', '#ef4444', '#06b6d4', '#8b5cf6', '#ec4899', '#f97316'],
        };

        // --- Disk Scheduling Functions ---

        function addRequest() {
            const requestTrack = parseInt(document.getElementById('disk-request').value);
            const diskSize = parseInt(document.getElementById('disk-size').value);

            if (isNaN(requestTrack) || requestTrack < 0 || requestTrack > diskSize) {
                console.error("Invalid track number. Must be between 0 and disk size.");
                return;
            }

            AppState.diskRequests.push(requestTrack);
            document.getElementById('disk-request').value = '';
            renderRequestList();
        }

        function removeRequest(index) {
            AppState.diskRequests.splice(index, 1);
            renderRequestList();
        }

        function renderRequestList() {
            const listElement = document.getElementById('disk-request-list');
            listElement.innerHTML = '';

            AppState.diskRequests.forEach((req, index) => {
                const tag = document.createElement('span');
                tag.className = 'inline-flex items-center px-3 py-1 text-sm font-medium bg-indigo-100 text-indigo-800 rounded-full cursor-pointer hover:bg-indigo-200 transition duration-150';
                tag.innerHTML = `${req}
                    <button onclick="removeRequest(${index})" class="ml-2 -mr-1 h-4 w-4 text-indigo-600 hover:text-indigo-900 transition duration-150" aria-label="Remove request">
                        &times;
                    </button>`;
                listElement.appendChild(tag);
            });
        }

        function runDiskVisualizer() {
            if (AppState.diskRequests.length === 0) {
                console.error("Please add at least one disk request.");
                return;
            }

            const initialHead = parseInt(document.getElementById('disk-head-position').value);
            const diskSize = parseInt(document.getElementById('disk-size').value);
            const algorithm = document.getElementById('disk-algorithm').value;

            if (isNaN(initialHead) || initialHead < 0 || initialHead > diskSize || isNaN(diskSize) || diskSize < 0) {
                console.error("Invalid Initial Head Position or Disk Size.");
                return;
            }

            let results;
            const params = {
                requests: [...AppState.diskRequests],
                initialHead: initialHead,
                diskSize: diskSize
            };

            // Ensure the initial head position is considered a 'request' for calculation accuracy
            const allRequests = [...AppState.diskRequests];

            switch(algorithm) {
                case 'fcfs':
                    results = calculateDiskFcfs(params);
                    break;
                case 'sstf':
                    results = calculateDiskSstf(params);
                    break;
                case 'scan':
                    results = calculateDiskScan(params);
                    break;
                case 'cscan':
                case 'look':
                case 'clook':
                    console.warn(`Algorithm ${algorithm.toUpperCase()} is not yet implemented. Running FCFS placeholder.`);
                    results = calculateDiskFcfs(params); // Fallback
                    break;
                default:
                    results = calculateDiskFcfs(params);
            }

            updateDiskResults(results);
            drawDiskMovement(results.movementSequence, diskSize);
        }

        /**
         * FCFS (First Come, First Served) Disk Scheduling Calculation
         */
        function calculateDiskFcfs({ requests, initialHead }) {
            let currentHead = initialHead;
            let totalSeekTime = 0;
            const movementSequence = [initialHead]; // Start with initial position

            requests.forEach(request => {
                const seekTime = Math.abs(request - currentHead);
                totalSeekTime += seekTime;
                currentHead = request;
                movementSequence.push(currentHead);
            });

            const avgSeekTime = requests.length > 0 ? totalSeekTime / requests.length : 0;

            return {
                movementSequence,
                totalSeekTime,
                avgSeekTime
            };
        }

        /**
         * SSTF (Shortest Seek Time First) Disk Scheduling Calculation
         * SSTF services the request that is closest to the current head position.
         */
        function calculateDiskSstf({ requests, initialHead }) {
            let currentHead = initialHead;
            let totalSeekTime = 0;
            const movementSequence = [initialHead];
            // Work on a mutable copy of requests
            let remainingRequests = [...requests];
            const originalLength = requests.length;

            while (remainingRequests.length > 0) {
                let shortestSeek = Infinity;
                let nextRequestIndex = -1;

                // Find the closest request to the current head position
                for (let i = 0; i < remainingRequests.length; i++) {
                    const seekTime = Math.abs(remainingRequests[i] - currentHead);
                    // Use < to prioritize shorter seek, ties are broken by index which is fine
                    if (seekTime < shortestSeek) {
                        shortestSeek = seekTime;
                        nextRequestIndex = i;
                    }
                }

                // Execute the move to the selected request
                const nextRequest = remainingRequests[nextRequestIndex];
                totalSeekTime += shortestSeek;
                currentHead = nextRequest;
                movementSequence.push(currentHead);

                // Remove the serviced request
                remainingRequests.splice(nextRequestIndex, 1);
            }

            const avgSeekTime = originalLength > 0 ? totalSeekTime / originalLength : 0;

            return {
                movementSequence,
                totalSeekTime,
                avgSeekTime
            };
        }

        /**
         * SCAN (Elevator) Disk Scheduling Calculation
         * Assumes head initially moves towards the largest track number (diskSize).
         */
        function calculateDiskScan({ requests, initialHead, diskSize }) {
            let currentHead = initialHead;
            let totalSeekTime = 0;
            const movementSequence = [initialHead];
            const originalLength = requests.length;

            // 1. Divide requests into two sets
            // Smaller requests (to be serviced during the sweep down to 0)
            const smaller = requests.filter(r => r < initialHead).sort((a, b) => b - a); // Sort descending
            // Larger requests (to be serviced during the sweep up to diskSize)
            const larger = requests.filter(r => r >= initialHead).sort((a, b) => a - b); // Sort ascending

            // 2. Head moves UP (towards diskSize) first
            let currentQueue = larger;
            
            // Process larger requests
            currentQueue.forEach(request => {
                totalSeekTime += Math.abs(request - currentHead);
                currentHead = request;
                movementSequence.push(currentHead);
            });
            
            // Move to the end of the disk (diskSize)
            totalSeekTime += Math.abs(diskSize - currentHead);
            currentHead = diskSize;
            movementSequence.push(currentHead);


            // 3. Head moves DOWN (towards 0) second
            currentQueue = smaller; // Already sorted descending
            
            // Process smaller requests
            currentQueue.forEach(request => {
                totalSeekTime += Math.abs(request - currentHead);
                currentHead = request;
                movementSequence.push(currentHead);
            });

            // Move to the beginning of the disk (0) - SCAN always sweeps end-to-end
            totalSeekTime += Math.abs(0 - currentHead);
            currentHead = 0;
            movementSequence.push(currentHead);


            const avgSeekTime = originalLength > 0 ? totalSeekTime / originalLength : 0;

            return {
                movementSequence,
                totalSeekTime,
                avgSeekTime
            };
        }

        function updateDiskResults(results) {
            document.getElementById('total-seek-time').textContent = results.totalSeekTime;
            document.getElementById('avg-seek-time').textContent = results.avgSeekTime.toFixed(2);
        }

        function drawDiskMovement(sequence, diskSize) {
            const canvas = document.getElementById('disk-movement-chart');
            const ctx = canvas.getContext('2d');
            
            // Adjust canvas size for responsiveness
            canvas.width = canvas.offsetWidth;
            canvas.height = 256;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (sequence.length < 2) return;

            const paddingX = 40;
            const paddingY = 30;
            const chartWidth = canvas.width - (2 * paddingX);
            const chartHeight = canvas.height - (2 * paddingY);
            
            // X-axis (Track numbers)
            const trackToX = (track) => paddingX + (track / diskSize) * chartWidth;
            // Y-axis (Time/Step) - Reversed so the movement goes down the chart
            const stepToY = (step) => paddingY + (step / (sequence.length - 1)) * chartHeight;


            // Draw X-axis line (Track range)
            ctx.beginPath();
            ctx.moveTo(paddingX, canvas.height - paddingY);
            ctx.lineTo(canvas.width - paddingX, canvas.height - paddingY);
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // X-axis labels (0, diskSize)
            ctx.fillStyle = '#374151';
            ctx.font = '12px Inter';
            ctx.textAlign = 'center';
            ctx.fillText('0', trackToX(0), canvas.height - paddingY + 20);
            ctx.fillText(diskSize, trackToX(diskSize), canvas.height - paddingY + 20);
            
            // Title
            ctx.font = '14px Inter';
            ctx.textAlign = 'left';
            ctx.fillText('Track Number', canvas.width - paddingX - 60, canvas.height - paddingY + 40);

            // Draw movement line and points
            ctx.beginPath();
            ctx.moveTo(trackToX(sequence[0]), stepToY(0));
            
            for (let i = 0; i < sequence.length; i++) {
                const x = trackToX(sequence[i]);
                const y = stepToY(i);
                
                // Draw line segment
                if (i > 0) {
                    ctx.lineTo(x, y);
                }

                // Draw point
                ctx.fillStyle = i === 0 ? AppState.colors[0] : AppState.colors[1];
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Add the track number label next to the point
                ctx.fillStyle = '#374151';
                ctx.textAlign = 'left';
                // Only label user-defined requests, and the initial head position
                // Check if the current point is the initial head or one of the original requests
                const isUserRequest = AppState.diskRequests.includes(sequence[i]) || i === 0;

                // Add labels for key points (initial, requests, and the ends of the disk)
                if (isUserRequest || sequence[i] === 0 || sequence[i] === diskSize) {
                    ctx.fillText(sequence[i], x + 8, y + 4);
                }
            }
            
            ctx.strokeStyle = AppState.colors[0]; // Primary color for the line
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // --- Initialization ---

        window.onload = function() {
            // Add initial placeholder requests for immediate demonstration
            AppState.diskRequests = [82, 170, 43, 140, 24, 16];
            renderRequestList();
            
            // Default to SCAN for the first run to show the new feature
            document.getElementById('disk-algorithm').value = 'scan'; 
            runDiskVisualizer(); 

            // Re-draw on window resize for responsiveness (throttled)
            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    runDiskVisualizer();
                }, 100);
            });
        };
    </script>
</body>
</html>
